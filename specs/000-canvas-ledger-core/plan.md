# Implementation Plan: canvas-ledger (cl)

**Date**: 2026-01-06
**Spec**: `specs/000-canvas-ledger-core/spec.md` (v1.0)
**Constitution**: `.specify/memory/constitution.md` (v1.0.0)

## Summary

canvas-ledger is a local, instructor-owned CLI tool that maintains a durable,
queryable historical record of Canvas LMS metadata. The implementation must
satisfy seven canonical query families (involvement timeline, person history,
performance summary, responsibility clarity, roster composition, enrollment
drift, course identity continuity) while preserving the dual-truth model
(observed vs. declared) and supporting safe, repeatable, incremental ingestion.

**Canvas is treated as a read-only data source.** cl never mutates Canvas state;
all writes are to the local ledger only.

This plan describes the architecture, phased roadmap, and key design decisions
needed to generate concrete implementation tasks.

## Technical Context

**Language/Version**: Python 3.13+
**Environment/Deps**: `uv` for environment and dependency management (per constitution);
avoid `pip` or alternative managers; avoid the `uv pip` interface
**CLI Framework**: Typer
**Canvas API**: `canvasapi` for supported endpoints; `httpx` as fallback for gaps/edge endpoints
**Storage**: SQLite (single local file)
**ORM**: SQLModel (SQLAlchemy underneath)
**Migrations**: Alembic
**Testing**: pytest
**Target Platform**: macOS, Linux (any platform with Python 3.13+)
**Project Type**: Single CLI application
**Performance Goals**: Handle 100+ offerings, 1000+ enrollments per offering
**Constraints**: Offline-capable after ingestion; no cloud dependencies beyond Canvas API

**Operational defaults (may evolve)**: WAL mode, foreign key enforcement, busy timeout

### Tooling Workflow

All development and runtime operations use `uv` as the standard workflow:

- `uv sync` to install/update dependencies
- `uv run cl ...` to run CLI commands
- `uv run pytest ...` to run tests
- Dependencies managed via `pyproject.toml`; lock file committed

## Constitution Check

*GATE: Verified against Constitution v1.0.0*

| Principle | Compliance |
|-----------|------------|
| I. Metadata, Not Content | Content syncing explicitly out of scope |
| II. Observed vs Declared Truth | Dual-truth model is core to design |
| III. Historical Accuracy | Drift detection and non-destructive updates |
| IV. Local, Inspectable, Durable | Single SQLite file, no hidden services |
| V. CLI-First, Composable | All functionality via CLI, structured output |
| VI. Loose Coupling | Exports as public interface, DB as internal |
| VII. Schema Evolution | Migration strategy included in plan |
| VIII. Minimal Surface Area | Phased growth tied to canonical queries |
| IX. Instructor-Centric | Normal permissions assumed throughout |
| X. Correctness Beats Cleverness | Explicit annotations, no inference |

No violations. Plan proceeds.

## Project Structure

### Documentation

```text
specs/000-canvas-ledger-core/
├── spec.md              # Product specification (approved)
├── plan.md              # This file
└── tasks.md             # Generated by /speckit.tasks (next step)
```

### Source Code

```text
src/
├── cl/
│   ├── __init__.py
│   ├── cli/             # CLI entry points and command handlers (Typer)
│   │   ├── __init__.py
│   │   └── main.py      # CLI application root
│   ├── canvas/          # Canvas API client (isolated, read-only)
│   │   ├── __init__.py
│   │   └── client.py
│   ├── ledger/          # Core ledger logic (persistence, queries)
│   │   ├── __init__.py
│   │   ├── store.py     # Database operations
│   │   ├── ingest.py    # Ingestion orchestration
│   │   └── queries.py   # Query implementations
│   ├── annotations/     # Declared truth handling
│   │   ├── __init__.py
│   │   └── manager.py
│   ├── export/          # Structured output (JSON/CSV)
│   │   ├── __init__.py
│   │   └── formatters.py
│   ├── migrations/      # Alembic migration scripts
│   │   └── ...
│   └── config/          # Configuration and secrets
│       ├── __init__.py
│       └── settings.py

tests/
├── unit/
├── integration/
└── fixtures/
```

**Structure Decision**: Single project layout. No web frontend, no separate
backend. The `src/cl/` package contains all application code.
Tests are in a parallel `tests/` directory.

---

## High-Level Architecture

### Major Components

#### 1. Configuration & Secrets (`config/`)

Manages Canvas API credentials, database location, and user preferences.

**Secret retrieval uses a pluggable provider model:**

- **Preferred**: 1Password integration (user supplies retrieval details)
- **Fallback**: Environment variable (`CANVAS_API_TOKEN`)
- Tokens are never stored in config files by default
- Config file (`~/.config/cl/config.toml`) holds non-secret settings only

**Other configuration:**

- Database path configurable (default: `~/.local/share/cl/ledger.db`)
- Canvas base URL configurable
- No sensitive data in code or version control

#### 2. Canvas API Client (`canvas/`)

Isolated module for all Canvas REST API interactions.

**Read-only posture**: cl treats Canvas as a read-only source and never mutates
Canvas state. All API calls are GET requests for data retrieval.

- Stateless HTTP client; receives credentials from config/secret provider
- Handles pagination, rate limiting, and retry logic
- Returns normalized data structures (not raw JSON)
- API failures raise explicit exceptions (never silently fail)
- Supports required endpoints only:
  - List courses for current user (all roles)
  - List sections for a course
  - List enrollments for a course/section (with grades)
  - Get user details

#### 3. Persistence Layer (`ledger/store.py`)

Database operations and schema management.

- Single SQLite file as the sole persistence mechanism
- All database access goes through this module boundary
- Within this layer: ORM (SQLModel) for standard operations, raw SQL permitted
  for clarity in bulk operations or complex queries
- Supports observation timestamps on all Canvas-sourced data
- Ingestion runs tracked with metadata (timestamp, scope, counts)

**History and drift guarantees** (implementation approach determined in tasks):

- Historical observations are preserved; prior states are not lost
- Non-destructive: observed data is never deleted from the ledger
- Drift-aware: changes between ingestion runs are detected and recorded
- "Last seen" / ingestion-run tracking enables reconstruction of state over time

The exact schema, keys, and constraints are a deliberate deliverable during task
implementation and will be designed with review at that stage.

#### 4. Ingestion Engine (`ledger/ingest.py`)

Orchestrates data retrieval and persistence.

- Two ingestion scopes:
  - **Catalog ingestion**: All courses visible to user (lightweight)
  - **Deep ingestion**: Sections + enrollments for selected offerings
- Idempotent: Same input produces same ledger state (no duplicates)
- Drift-aware: Detects changes from prior observations
- Records ingestion runs with metadata (timestamp, scope, counts)
- Never deletes observed data, even if missing from Canvas

#### 5. Query Engine (`ledger/queries.py`)

Implements the canonical query families.

- Queries read from the persistence layer
- Merges observed data with declared annotations for output
- Supports filtering by term, offering, person, role, state
- Returns structured data (dicts/lists) for formatting layer

#### 6. Annotation Manager (`annotations/`)

Manages user-declared truth.

- Annotations are stored separately from observed data
- Supported annotation types (initial):
  - Offering-level: lead instructor, grade-responsible designation
  - User-level: involvement classification (for the user's own roles)
  - Offering-level: course alias/grouping
- Annotations are timestamped and versioned
- Annotations survive ingestion runs (never overwritten by Canvas data)
- CRUD operations via CLI commands

#### 7. Export & Output (`export/`)

Formats query results for output.

- Supports JSON and CSV output formats
- Consistent structure across all query types
- Designed as stable contract for downstream tools
- Human-readable default; `--format json` or `--format csv` for scripts

#### 8. CLI Interface (`cli/`)

User-facing command-line interface.

- Built with Typer
- Organized into command families (see CLI Surface Area below)
- All commands return structured output to stdout
- Errors go to stderr with clear messages
- Exit codes indicate success (0) or failure (non-zero)

#### 9. Logging & Audit

Operational visibility without separate tooling.

- Configurable log level (default: warnings and errors)
- Ingestion runs logged with timestamps and counts
- API errors logged with context (no secrets)
- Audit trail via observation timestamps in database

---

## Data Truth Model

### Observed Truth

Data exactly as reported by Canvas at the time of observation.

**Characteristics**:
- Timestamped with observation time
- Historical states are preserved (not lost on re-ingestion)
- Non-destructive: never deleted, even if Canvas data changes or disappears
- Identified by Canvas IDs (course_id, user_id, enrollment_id, etc.)

**Conceptual entities** (schema deferred to tasks):
- Offering (course): name, code, term, workflow_state
- Person (user): name, sis_user_id, login_id
- Enrollment: user, course, section, role, state, grades
- Section: name, sis_section_id
- Term: name, start_date, end_date

### Declared Truth

User-asserted facts that coexist with observed data.

**Characteristics**:
- User-controlled (create, update, delete via CLI)
- Timestamped with creation/modification time
- Independent of ingestion (survives re-ingestion)
- Surfaced alongside observed data in queries
- Never overwrites observed data; adds context

**Initial annotation types**:

1. **Lead/Grade-Responsible Instructor**
   - Scope: Offering
   - Purpose: Distinguish primary instructor in co-taught courses
   - Data: offering_id, person_id, designation (lead | grade_responsible)
   - Shown alongside Canvas-reported instructor enrollments

2. **User Involvement Classification**
   - Scope: User + Offering (for the current user's own involvement)
   - Purpose: Capture user's actual role when Canvas role is insufficient
   - Data: offering_id, classification (e.g., "developed course", "guest lecturer")
   - Supplements Canvas-reported role

3. **Course Alias/Grouping**
   - Scope: Multiple offerings
   - Purpose: Associate related courses (renumbering, special topics)
   - Data: alias_name, list of offering_ids
   - Enables cross-offering queries by logical course identity

### Truth Surfacing

Queries return both observed and declared data, clearly distinguished:

- Observed data shown with observation timestamp
- Declared data shown with annotation timestamp and type
- No merging or inference; both truths visible
- Output format makes distinction clear (e.g., separate fields)

---

## Ingestion Approach

### Catalog Ingestion (Phase 1 scope)

**Purpose**: Build initial ledger of all courses visible to the user.

**Behavior**:
1. Call Canvas API to list all courses for current user (any role)
2. For each course, record offering metadata and user's enrollment(s)
3. Record term information for each offering
4. Store observation timestamp for all records
5. Log ingestion run metadata (timestamp, offering count)

**Idempotency**:
- If offering already exists with same Canvas data, no new observation needed
- If offering exists with different data, drift is recorded
- User enrollments in offerings handled same way

**Output**: Count of offerings ingested, new vs. existing

### Deep Ingestion (Phase 3 scope)

**Purpose**: Ingest sections, enrollments, and people for selected offerings.

**Behavior**:
1. User specifies one or more offerings (by Canvas ID or selection)
2. For each offering:
   - Fetch sections; record with observation timestamp
   - Fetch enrollments (all roles, all sections); record with grades
   - Fetch person data for each enrolled user; record
3. Record ingestion run metadata (timestamp, offering scope, counts)

**Idempotency**:
- Same logic as catalog ingestion
- Exact keying and drift-tracking approach determined during schema design
- Grade changes across ingestion runs are detected and preserved

**Incremental safety**:
- Deep ingestion does not affect catalog-level data
- Can run catalog ingestion and deep ingestion independently
- No data loss if deep ingestion fails partway

### Drift Detection (Phase 4 scope)

**Purpose**: Identify and record changes between ingestion runs.

**Conceptual approach**:
- Compare current observation to most recent prior observation
- If different, record the change (implementation TBD in schema design)
- Prior states are preserved
- Queries can show drift history on request

**What constitutes drift**:
- Offering: name, code, workflow_state changed
- Enrollment: state changed (active → dropped), grades changed
- Person: name or identifiers changed

**Reporting**:
- Ingestion run output includes drift summary
- Query flag to show historical states (default: most recent only)

### Non-Destructive Principle

- Observed data is never deleted from the ledger
- If a course/enrollment disappears from Canvas, ledger retains it
- Ingestion records "last seen" timestamp; absence is implicit
- Queries can filter by "active" (seen in latest ingestion) if needed

---

## Migration Strategy

### Principles

- Schema changes are expected and planned for
- Migrations are forward-only (no rollbacks)
- Migrations are explicit and versioned
- Database file is portable; migrations run on open if needed

### Implementation Approach

- Alembic for migration management
- Migrations stored in `src/cl/migrations/`
- Auto-migration on database open (check version, run pending)
- Backup before migration (copy database file)
- Alembic migrations are maintained explicitly; autogeneration may be used when
  appropriate with review

### Migration types anticipated

- Adding new columns to existing tables (additive)
- Adding new tables for new features
- Adding indexes for query performance
- Restructuring for drift tracking (phase 4)

### Safety

- Migrations tested before release
- Backup created automatically before each migration
- Failure leaves database in prior state (transaction rollback)

---

## CLI Surface Area

### Command Families

#### `cl config`
Configuration management.

- `cl config init` — Initialize configuration (API token, paths)
- `cl config show` — Display current configuration (redact secrets)
- `cl config set <key> <value>` — Update configuration value

#### `cl db`
Database operations.

- `cl db migrate` — Run pending migrations
- `cl db status` — Show migration status and DB info

#### `cl ingest`
Data ingestion from Canvas.

- `cl ingest catalog` — Ingest all visible courses (catalog mode)
- `cl ingest offering <id>` — Deep ingest for specific offering(s)
- `cl ingest status` — Show last ingestion run details

#### `cl query`
Query the ledger.

- `cl query my-timeline` — User's involvement history (canonical Q1)
- `cl query person <id>` — Person's enrollment history (Q2)
- `cl query person <id> --grades` — Person's performance summary (Q3)
- `cl query offering <id>` — Offering roster by section (Q5)
- `cl query offering <id> --instructors` — Instructors with declared lead (Q4)
- `cl query drift <scope>` — Enrollment changes over time (Q6)
- `cl query alias <name>` — Query by course alias (Q7)

#### `cl annotate`
Manage declared truth.

- `cl annotate lead <offering_id> <person_id>` — Declare lead instructor
- `cl annotate involvement <offering_id> <classification>` — Classify user's involvement
- `cl annotate alias create <name> <offering_ids...>` — Create course alias
- `cl annotate alias add <name> <offering_id>` — Add offering to alias
- `cl annotate list [--offering <id>]` — List annotations
- `cl annotate remove <annotation_id>` — Remove annotation

#### `cl export`
Structured data export.

- `cl export offerings [--format json|csv]` — Export all offerings
- `cl export enrollments <offering_id> [--format json|csv]` — Export roster
- `cl export person <id> [--format json|csv]` — Export person's history

### Output Conventions

- Default output: Human-readable table or summary
- `--format json`: JSON array/object to stdout
- `--format csv`: CSV with headers to stdout
- `--quiet`: Suppress non-essential output (for scripts)
- Errors: stderr with descriptive message, non-zero exit code

---

## Phased Roadmap

### Phase 0: Foundation

**Goal**: Project scaffolding, configuration, database setup.

**Delivers**:
- Project structure with `uv` environment
- Configuration module with pluggable secret provider (1Password preferred)
- SQLite database initialization (WAL, FK, busy timeout)
- Alembic migration setup
- Basic CLI skeleton (Typer)

**Canonical queries enabled**: None (infrastructure only)

**Exit criteria**:
- `cl config init` works
- `cl db migrate` creates database with initial schema
- `cl db status` reports migration state
- Tests pass

---

### Phase 1: Catalog Ingestion + My Timeline

**Goal**: Ingest all visible courses; answer "what courses have I been involved in?"

**Delivers**:
- Canvas API client (courses list, terms) — read-only
- Catalog ingestion command
- Offering and term persistence
- User enrollment persistence (user's own roles)
- `cl query my-timeline` command
- JSON/CSV export for offerings

**Canonical queries enabled**:
- Q1: My involvement timeline (observed roles only)

**Exit criteria**:
- `cl ingest catalog` retrieves and stores all visible courses
- `cl query my-timeline` shows offerings with terms and roles
- Repeated ingestion is idempotent
- Output available in JSON and CSV

---

### Phase 2: Annotations Framework

**Goal**: Enable declared truth; annotate involvement and responsibility.

**Delivers**:
- Annotation storage (separate from observed data)
- `cl annotate` commands (lead instructor, involvement classification)
- Query output includes declared annotations alongside observed data
- Annotations survive re-ingestion

**Canonical queries enabled**:
- Q1: My involvement timeline (with declared involvement)
- Q4: Declared vs. observed instructors (partial—no deep enrollments yet)

**Exit criteria**:
- User can add lead instructor annotation
- User can add involvement classification
- `cl query my-timeline` shows both observed roles and declared involvement
- Re-running `cl ingest catalog` does not affect annotations

---

### Phase 3: Deep Ingestion + Rosters

**Goal**: Ingest sections, enrollments, people for selected offerings.

**Delivers**:
- Canvas API client extensions (sections, enrollments, users) — read-only
- Deep ingestion command
- Section persistence
- Enrollment persistence (all roles, all users, grades)
- Person persistence
- `cl query offering <id>` — roster by section
- `cl query offering <id> --instructors` — full instructor comparison
- `cl query person <id>` — enrollment history across offerings

**Canonical queries enabled**:
- Q2: Person enrollment history
- Q4: Declared vs. observed instructors (complete)
- Q5: Offering composition snapshot

**Exit criteria**:
- `cl ingest offering <id>` retrieves sections, enrollments, people
- `cl query offering <id>` shows roster grouped by section
- `cl query person <id>` shows enrollments across ingested offerings
- Repeated deep ingestion is idempotent

---

### Phase 4: Drift Detection + History

**Goal**: Track enrollment changes over time.

**Delivers**:
- Drift detection in ingestion (compare to prior observations)
- Historical observation storage (approach determined in schema design)
- Ingestion run logging (what changed, counts)
- `cl query drift` commands
- Query flags to show historical states

**Canonical queries enabled**:
- Q6: Enrollment drift over time

**Exit criteria**:
- Second ingestion run detects and records changes
- `cl query drift person <id>` shows enrollment state changes
- `cl query drift offering <id>` shows roster changes
- Prior observations preserved and queryable

---

### Phase 5: Performance Summaries

**Goal**: Surface Canvas-reported grades in queries.

**Delivers**:
- Grade data storage during enrollment ingestion (already captured in Phase 3)
- `cl query person <id> --grades` command
- Grade drift tracking (grade changes across observations)
- Export includes grade data

**Canonical queries enabled**:
- Q3: Person performance summary

**Exit criteria**:
- `cl query person <id> --grades` shows final/current grade per offering
- Grade changes over time visible in drift queries
- Missing grades handled gracefully (null, not error)

---

### Phase 6: Course Identity + Aliasing

**Goal**: Support course renumbering and special topics coherence.

**Delivers**:
- Course alias annotations
- `cl annotate alias` commands
- `cl query alias <name>` command
- Aggregated views across aliased offerings

**Canonical queries enabled**:
- Q7: Course identity continuity

**Exit criteria**:
- User can create alias grouping multiple offerings
- `cl query alias <name>` returns all associated offerings
- Enrollment queries can span alias

---

## Drift and History Representation

### Conceptual Model

Each observed entity has a history of observations:

- **Observation**: A snapshot of an entity at a point in time
- **Observation timestamp**: When the data was fetched from Canvas
- **Entity identity**: Canvas IDs (course_id, user_id, etc.)

When ingestion runs:
1. Fetch current state from Canvas
2. Compare to most recent observation in ledger
3. If different (drift), record appropriately (implementation TBD)
4. If same, update "last confirmed" timestamp

### What is stored

- Current state and historical states (preserved, not deleted)
- Observation timestamps
- Ingestion run metadata (when, what scope, summary of changes)

### What is queryable

- Default: Most recent observation for each entity
- With flag: Full observation history
- Drift summary: Changes between observations

### Non-deletion guarantee

- Entities that disappear from Canvas retain all prior observations
- "Disappeared" status is implicit (not seen in latest ingestion)
- No explicit "deleted" state; absence from current ingestion is the signal

---

## Risks and Mitigations

### API Variability

**Risk**: Canvas API behavior differs across institutions or changes over time.

**Mitigation**:
- API client returns normalized structures, insulating ledger from raw API
- Error handling for unexpected responses (log and skip, don't crash)
- API version not assumed; rely on documented stable endpoints only

### Enrollment Edge Cases

**Risk**: Complex enrollment scenarios (cross-listed courses, multiple sections,
role combinations) may not map cleanly.

**Mitigation**:
- Store Canvas data as-is, without interpretation
- Let queries surface complexity rather than hiding it
- Annotations allow user to clarify when Canvas data is confusing

### Missing Grade Data

**Risk**: Not all enrollments have grades (e.g., auditors, TAs, incomplete courses).

**Mitigation**:
- Grades stored as nullable fields
- Queries handle missing grades gracefully (show "—" or null)
- No errors on missing grade data

### Deleted Courses in Canvas

**Risk**: Courses may be deleted from Canvas after being ingested.

**Mitigation**:
- Non-destructive policy: ledger never deletes observed data
- Deleted courses remain queryable with full history
- "Last seen" timestamp indicates when course was last confirmed

### Permission Changes

**Risk**: User may lose access to courses they previously ingested.

**Mitigation**:
- Local data remains (already observed, already stored)
- Re-ingestion will not see those courses (no new observations)
- No error; user simply cannot refresh data for inaccessible courses

### Large Data Volumes

**Risk**: Users with many courses or courses with many enrollments.

**Mitigation**:
- Pagination in API client
- Deep ingestion is per-offering (user controls scope)
- SQLite handles tens of thousands of enrollments comfortably
- Indexes on common query paths

### API Failures Mid-Ingestion

**Risk**: Network or API error during ingestion corrupts local data.

**Mitigation**:
- Transactional writes: ingestion run either completes or rolls back
- Partial success: per-offering transactions for deep ingestion
- Clear error messages indicating what failed and why
- Local data never in inconsistent state

### Secrets Management

**Risk**: API token exposed in config file or logs.

**Mitigation**:
- Pluggable secret provider; 1Password integration preferred
- Environment variable fallback (not config file storage)
- Token never logged, even at debug level
- Config file contains non-secret settings only

---

## Complexity Tracking

No constitution violations identified. Plan uses simple, explicit approaches
throughout. No enterprise patterns, no inference engines, no external services.

| Potential Concern | Resolution |
|-------------------|------------|
| Drift tracking adds storage | Acceptable per Principle III (historical accuracy) |
| Annotation system adds complexity | Minimal; required by Principle II (declared truth) |
| Migration system adds code | Required by Principle VII (schema evolution) |
| Secret provider abstraction | Minimal; avoids insecure token storage |

All complexity is justified by explicit constitutional principles.
